## 关于http协议详解 完善http协议知识体系

https://juejin.im/post/5e945c03f265da47e7527272

## 简述TCP三次握手

- 第一次握手: 建立连接。客户端发送连接请求，发送SYN报文，将seq设置为X（某个值）。然后，客户端进入SYN_SEND状态，等待服务器的确认。
- 第二次握手: 服务器收到客户端的SYN报文段。需要对这个SYN报文段进行确认，发送ACK报文，将ack设置为X+1。同时，自己还要发送SYN请求信息，将seq为Y。服务器端将上述所有信息一并发送给客户端，此时服务器进入SYN_RECV状态。
- 第三次握手: 客户端收到服务器的ACK和SYN报文后，进行确认，然后将ack设置为Y+1，seq设置为X+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。

第三次握手的原因是为了防止已失效的连接请求报文段突然又传回给服务器进程从而产生错误。假设客户端发送第一次连接请求由于网络滞留了，于是客户端又发送了一次请求并成功建立连接，数据传输完毕后就释放了连接。在释放连接后的某个时间段内客户端的第一次报文段又到达了服务器并被服务器进程确认，如果没有第三次握手，则服务器会一直等待客户端发送数据，从而浪费许多资源。 

## 从输入URL到页面加载完成，发生了什么？

可参考：[how browers work](http://taligarsiel.com/Projects/howbrowserswork1.htm)

1、用户输入URL；

2、 浏览器首先依次查询自身缓存，系统缓存和路由器缓存的记录，如果没有则查询本地host文件，还没有就向DNS服务器发送域名解析请求；

3、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;

4、解析出 IP 地址后，根据该 IP 地址和默认端口 80（如果输入的URL中有端口号就用你输入的）， 向服务器指定端口发起TCP连接请求，通过运输层，网络层，数据链路层，物理层到达服务器，经过三次握手后建立TCP连接 ；

5、三次握手后，就可以传输数据了，客户端将要发送的内容构建成HTTP请求报文并封装在TCP包中，通过TCP协议发送到服务器指定端口； 

6、 服务器解析HTTP请求并按照报文格式封装成需要的HTTP对象，返回给浏览器。

7、数据传输完毕后，就通过四次分手将客户端和服务器的连接释放。 

8、 浏览器根据拿到的响应报文进行页面的解析和渲染

**ps：浏览器解析和渲染**

浏览器根据拿到的响应报文进行解析和页面的渲染。 在渲染页面之前，需要构建DOM树和CSSOM树。 浏览器是一个边解析边渲染的过程。 

1、构建DOM树

HTML文档会被解析成一棵以document为根的DOM树，解析过程中如果遇到JavaScript，则会暂停解析并传输下载相应的文件造成阻塞，故推荐将JavaScript脚本放在HTML文件的后面。

2、构建CSSSOM树

浏览器根据外部样式，内部样式和内联样式来解析CSS，构建CSSSOM树。

3、构建渲染树和布局

DOM树和CSSOM树构建完毕后会融合成渲染树，然后浏览器会确认页面各元素的位置。

4、页面绘制和优化

浏览器根据布局结果进行页面的绘制，并优化页面内容，减小CPU消耗。

渲染结束后整个页面就呈现在我们面前了。

## 如何实现浏览器内多个标签页之间的通信?

1、WebSocket：因为websokect是全双工通信，所以可以实现多个标签页之前的通信；

2、SharedWorker： html5浏览器的新特性， 可以多个标签页、iframe共同使用的 
3、 localstorage：是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信；

思路： onstorage以及storage事件，针对都是**非当前页面**对localStorage进行修改时才会触发，当前页面修改localStorage不会触发监听函数。 

```javascript
window.onstorage = (e) => {console.log(e)}
```

或者

```javascript
window.addEventListener("storage",function(event){
   　$("#name").val(event.key+”=”+event.newValue);
}); 
```

注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常

4、 使用cookie+setInterval

这个方法使用定时器不断栓下，是相当浪费资源的，虽然能实现方案，但是不够优雅。

**思路：**

在页面A设置一个使用 setInterval 定时器不断刷新，检查 Cookies 的值是否发生变化，如果变化就进行刷新的操作。

由于 Cookies 是在同域可读的，所以在页面 B 审核的时候改变 Cookies 的值，页面 A 自然是可以拿到的。

## TCP与UDP的区别

TCP提供面向连接的，可靠的数据传输服务。以报文段的形式传输；

UDP提供无连接的，尽最大努力的数据传输服务。以用户数据报的形式传输。

TCP与UDP的区别： TCP协议相对于UDP协议的特点是：TCP协议提供面向连接、字节流和可靠的传输。 

## HTTP响应码你都知道哪些？都是什么意思？

**常见状态码**

        200 - OK 请求成功，客户端发过来的数据被正常处理
        
        204 - Not Content 正常响应，没有实体
        
        206 - Partial Content 范围请求，返回部分数据，响应报文中由Content-Range指定实体内容
    
        301 - Moved Permanently 请求永久重定向，转移到其它URL
    
        302 - Found 请求临时重定向
        
        303 - See Other 和302类似，但必须用GET方法
    
        304 - Not Modified) 状态未改变， 配合(If-Match、If-Modified-Since、If-None_Match、If-Range、If-Unmodified-Since) 
        
        307 - Temporary Redirect 临时重定向，和302类似，不该改变原请求方法
    
        400 - Bad Request 客户端请求报文存在语法错误
    
        401 - unauthorized 客户端请求没有经过授权
    
        403 - Forbidden 客户端的请求被服务器拒绝，一般为客户端没有访问权限
    
        404 - Not Found 服务器上无法找到请求的资源
    
        500 - Internal Server Error 服务器内部错误
        
        503 - Service Unavailable 服务器处于超负载或正在停机维护

## HTTP协议的工作流程？

- 1、地址解析
- 2、封装HTTP请求数据包

- 3、封装TCP包，建立TCP链接（TCP的三次握手）

- 4、客户端发送请求命令

- 5、服务器响应
- 6、服务器关闭TCP链接

## 什么是长链接，为什么需要长连接？

长连接也可以成为持久链接，HTTP/1.1默认开启长连接（持久链接）， 数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据（一个TCP连接上可以传送多个HTTP请求和响应）； 

**为什么需要长连接？**

TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。  随着网页加载的外部资源越来越多，这个问题就愈发突出了。 

所以， HTTP 1.0版本的性能比较差。 解决方法：在发送请求时，设置字段：

```http
Connection: keep-alive
```

 这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。  一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。 

而HTTP/1.1默认开启的， 不用声明`Connection: keep-alive`。 

## HTTP/2的信道复用又为什么能提高性能？

在 HTTP/2 中，四大特性：头部压缩、二进制流、服务器推送、多路复用。

为什么说HTTP /2 的信道复用能提高性能呢？

- 同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。
- 并行交错地发送多个请求/响应，请求/响应之间互不影响。
- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。

## 针对HTTP/1.1的优化有哪些HTTP/2不在适用？

- **JS文件的合并**。我们现在优化的一个主要方向就是尽量的减少HTTP的请求数， 对我们工程中的代码，研发时分模块开发，上线时我们会把所有的代码进行压缩合并，合并成一个文件，这样不管多少模块，都请求一个文件，减少了HTTP的请求数。但是这样做有一个非常严重的问题：文件的缓存。当我们有100个模块时，有一个模块改了东西，按照之前的方式，整个文件浏览器都需要重新下载，不能被缓存。现在我们有了`HTTP/2`了，模块就可以单独的压缩上线，而不影响其他没有修改的模块。
- **多域名提高浏览器的下载速度**。之前我们有一个优化就是把css文件和js文件放到2个域名下面，这样浏览器就可以对这两个类型的文件进行同时下载，避免了浏览器6个通道的限制，这样做的缺点也是明显的，1.DNS的解析时间会变长。2.增加了服务器的压力。有了`HTTP/2`之后，根据上面讲的原理，我们就不用这么搞了，成本会更低。

##  **HTTP1.0 和 1.1 现存的一些问题** 

1. HTTP1.x 在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。
2. HTTP1.x 在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。
3. HTTP1.x 在使用时，header 里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求 header 基本不怎么变化，尤其在移动端增加用户流量。
4. 虽然 HTTP1.x 支持了 keep-alive，来弥补多次创建连接产生的延迟，但是 keep-alive 使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务 (例如图片存放网站)，keep-alive 可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。

## HTTPS和HTTP的区别

1. HTTPS协议需要到CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。
2. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由HTTP+SSL协议构建的可进行加密传输、身份认证的网络协议，可以有效的防止运营商劫持，解决了防劫持的一个大问题，比http协议安全。

## 如何将HTTP变为HTTPS？

**如果一个网站要全站由 HTTP 替换成 HTTPS，可能需要关注以下几点：**

1. 安装 CA 证书，一般的证书都是需要收费的，
2. 在购买证书之后，在证书提供的网站上配置自己的域名，将证书下载下来之后，配置自己的 web 服务器，同时进行代码改造。
3. HTTPS 降低用户访问速度。[SSL 握手](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)，HTTPS 对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。在很多场景下，HTTPS 速度完全不逊于 HTTP，如果使用 SPDY，HTTPS 的速度甚至还要比 HTTP 快。
4. 相对于 HTTPS 降低访问速度，其实更需要关心的是服务器端的 CPU 压力，HTTPS 中大量的密钥算法计算，会消耗大量的 CPU 资源，只有足够的优化，HTTPS 的机器成本才不会明显增加。

## 什么是缓存？

缓存HTTP的仓库，使常用页面的副本可以保存在离客户端更近的地方。

## HTTP的缓存机制

HTTP的缓存分为强缓存和协商缓存（对比缓存）。

> **HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，可将其分为强制缓存，对比缓存。** 

- 强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互
- 两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则

## 如何高效利用缓存，上线前端代码？

### 1、缓存时间过长，发布上线了，用户端还用缓存，会有bug

### 2、缓存时间过短，重复加载文件过多，浪费带宽

一般我的处理方式是：

step1：我们不让 html 文件缓存（ 静态资源（css、js 、image、audio等） ），每次访问 html 都去请求服务器。所以浏览器每次都能拿到最新的html资源。

 step2：将 静态资源（css、js 、image、audio等）原来的文件名加上每次打包的版本号，或者时间戳、指纹，这样的好处是，可以知道静态资源时哪次打包的，哪些资源时这次更改的，如果出现错误，需要回溯版本，也可以快速回溯。最好使用：文件名+hash+后缀名 例如：`<scrit src="/a.sdsf123s.js"></script>`

step3：先上线静态资源，在上线html

我们可以利用webpack工程化工具解决。

## HTTP 如何处理大文件的传输？

HTTP针对大文件的传输场景，可以使用`范围请求`来解决，客户端将资源一部分一部分传输。

一般是：压缩、分块、范围请求、多端数据的流程。

**那范围请求是怎么处理的呢？**

响应头使用：` Accept-Ranges ` 用来告知客户端这边是支持范围请求的;

请求头使用: `Rang`来制定请求哪一部分。` Range: bytes=x-y `

` bytes=x-y` 表示范围格式有：

- **0-y**表示从开始到第 y 个字节。
- y- 表示从第 y 字节到文件终点。
- **-y**表示文件的最后y个字节。
-   **x-y** 表示文件第x－y字节范围的内容 

服务器收到请求之后，首先验证范围**是否合法**，如果越界了那么返回`416`错误码，否则读取相应片段，返回`206`状态码。

同时，服务器需要添加`Content-Range`字段，这个字段的格式根据请求头中`Range`字段的不同而有所差异。

对于`单段数据`的请求，返回的响应如下:

```
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100

。。。
```

值得注意的是`Content-Range`字段，`0-9`表示请求的返回，`100`表示资源的总大小，很好理解。

**多段数据**

接下来我们看看多段请求的情况。得到的响应会是下面这个形式:

```
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96


--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--
```

这个时候出现了一个非常关键的字段`Content-Type: multipart/byteranges;boundary=00000010101`，它代表了信息量是这样的:

- 请求一定是多段数据请求
- 响应体中的分隔符是 00000010101

因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上`--`表示结束。

## 什么是代理？

代理是位于客户端和服务器之间的HTTP中间实体。接收所有客户端的HTTP请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）。

## 什么是Agent代理？

用户Agent代理是代表用户发起HTTP的客户端程序。比如Web浏览器。另外有些自动发送HTTP请求并获取内容的代理,比如“网络蜘蛛”或者“Web机器人”。

## 如何理解 HTTP 代理？

在web中，http代理是一种客户端和web服务器之间的一种实体。它既具备客户端的发起请求功能，还可以像web服务器一样返回响应。 

 代理和网关之间的首要差异是代理只能转发同一种协议，而网关能够转发多种协议。 

HTTP 代理存在两种形式，分别简单介绍如下：

第一种是 [RFC 7230 - HTTP/1.1: Message Syntax and Routing](http://tools.ietf.org/html/rfc7230)（即修订后的 RFC 2616，HTTP/1.1 协议的第一部分）描述的普通代理。这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。

第二种是 [Tunneling TCP based protocols through Web proxy servers](https://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01)（通过 Web 代理服务器用隧道方式传输基于 TCP 的协议）描述的隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接，但 CONNECT 最开始并不是 RFC 2616 - HTTP/1.1 的一部分，直到 2014 年发布的 HTTP/1.1 修订版中，才增加了对 CONNECT 及隧道代理的描述，详见 [RFC 7231 - HTTP/1.1: Semantics and Content](https://tools.ietf.org/html/rfc7231#section-4.3.6)。实际上这种代理早就被广泛实现。

## 什么是网关？

网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将HTTP流量转换成其他的协议。

## 什么是隧道？

隧道是建立起来之后，就会在两条连接之间对原始数据进行盲转发的HTTP应用程序。常见用途是通过HTTP连接承载加密的安全套接字层（SSL）流量，这样SSL流量就可以穿过只允许Web流量通过的防火墙了。



———————————————————————————————————

  **本文解析或者答案仅供参考，内容参考以下资料~~**

# **参考资料：**

《图解HTTP》

《HTTP权威指南》

 http://taligarsiel.com/Projects/howbrowserswork1.htm 

 https://cloud.tencent.com/document/product/302/19903 

 https://httpwg.org/specs/rfc7540.html 

 https://www.runoob.com/http/http-content-type.html 

 https://ye11ow.gitbooks.io/http2-explained/content/part2.html 

 https://github.com/creeperyang/blog/issues/23 

 https://www.cnblogs.com/coco1s/p/5777260.html 

 https://developer.mozilla.org/zh-CN/docs/Web/HTTP 

 https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP 